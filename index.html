<html>
	<head>
		<meta content="text/html;charset=utf-8" http-equiv="Content-Type">
		<title>Stars</title>
		<link href='http://fonts.googleapis.com/css?family=Montserrat' rel='stylesheet' type='text/css'>
		<style>
			html, body {
				margin: 0;
				padding: 0;
			}
			body {
				font-family: 'Montserrat', sans-serif;
				font-size: 22px;
			}
			canvas {
				position: absolute;
				left: 0;
				top: 0;
			}
		</style>
	</head>
	<body>
		<canvas id="static">No canvas support</canvas>
		<canvas id="field"></canvas>
		<script>
			// ==set-up==
			// =settings=
			var ANIMATION_FRAME = false;
			var SPEED = 150; // only used if ANIMATION_FRAME !== true
			var PAUSED = false;
			var DEBUG = false;
			var MODE = 0;
			var NUM_SICK = 1;
			var NUM_HEALTHY = 100;
			var PIXES_PER_CELL = 30;
			// =template methods=
			var noop = function (){};

			// =canvas=
			var canvas = document.getElementById('field');
			canvas.width = document.body.clientWidth;
			canvas.height = document.body.clientHeight;
			var ctx = canvas.getContext('2d');
			ctx.font = '8pt Arial';
			
			var staticCanvas = document.getElementById('static');
			staticCanvas.width = canvas.width;
			staticCanvas.height = canvas.height;
			var staticCtx = staticCanvas.getContext('2d');
			staticCtx.font = '8pt Arial';
			
			var model = {
				width: Math.round(canvas.width / PIXES_PER_CELL),
				height: Math.round(canvas.height / PIXES_PER_CELL),
				all: [],
				sick: [],
				healthy: [],
				obstacles: [],
				ratio: function() {
 					return this.sick.length+':'+this.healthy.length;
				},
				getPosHash: function(a) {
					return a.x * this.height + a.y;
				},
			};
			// ==populate==
			model.obstacles.push({x: 3, y: 3, w: 10, h: 10});
			model.obstacles.push({x: 20, y: 10, w: 20, h: 10});
			model.obstacles.push({x: 50, y: 2, w: 8, h: 20});
			//build the position hash that will never change
			var staticPosHash = {};
			for (var i in model.obstacles) {
				var obstacle = model.obstacles[i];
				for (x = obstacle.x; x < obstacle.x+obstacle.w; x++) {
					for (y = obstacle.y; y < obstacle.y+obstacle.h; y++) {
						staticPosHash[model.getPosHash({'x':x, 'y':y})] = true;
					}
				}
			}
			//populate sick
			for (var i=0; i<NUM_SICK; i++) {
				var s = randomPos();
				//keep trying until we aren't inside an obstacle
				while (staticPosHash[model.getPosHash(s)]) {
					s = randomPos();
				}
				s.type = 'sick';
				model.sick.push(s);
				model.all.push(s);
			}
			//populate healthy
			for (var i=0; i<NUM_HEALTHY; i++) {
				var h = randomPos();
				//keep trying until we aren't inside an obstacle
				while (staticPosHash[model.getPosHash(h)]) {
					h = randomPos();
				}
				h.type = 'healthy';
				model.healthy.push(h);
				model.all.push(h);
			}
			
			// ==events==
			// =mouse clicks=
			;(function () {
				var mouseDownPoint = {x:0, y:0};
				var mouseDownForce = null;
				var dragOffset = {x:0, y:0};
				function onmove(e) {
					var mouseMovePoint = {x: e.clientX, y: e.clientY};
					console.log('onmove');
				}
				canvas.onmousedown = function (e) {
					if (e.which == 1) {
						mouseDownPoint = {x: e.clientX, y: e.clientY};
						canvas.onmousemove = onmove;
						console.log('onmousedown');
					}
				};
				canvas.onmouseup = function (e) {
					if (e.which == 1) {
						var mouseUpPoint = {x: e.clientX, y: e.clientY};
						canvas.onmousemove = null;
						console.log('onmouseup');
					}
				};
				
				// =keyboard events=
				document.onkeyup = function (e) {
					e = e || window.event;
					switch (e.charCode || e.keyCode || e.key) {
						default:
							console.log(e.charCode || e.keyCode || e.key);
							break;
					}
				};
			})();
			
			
			drawBG(staticCtx);
			// ==callback==
			function tick() {
				if (!PAUSED) {
					move();
					ctx.clearRect(0, 0, canvas.width, canvas.height);
					draw(model.all);
				}
				if (DEBUG) {
					drawFramerate();
					drawFps();
					drawHashPos();
				}
				if (ANIMATION_FRAME) {
					requestAnimationFrame(tick);
				}
			}
			requestAnimationFrame(tick);

			// ==movement==
			function move() {
				var i, x, y,
					posMap = {}, //location sensitve hash map of all actors
					posHash,
					obstacle,
					sick, 
					healthy;
				//copy the staticPosHash
				for (i in staticPosHash) {
					posMap[i] = true;
				}
				//move sick
				for (i in model.sick) {
					sick = model.sick[i];
					moveRandom(sick);
					wrap(sick);
					posHash = model.getPosHash(sick);
					if (posMap[posHash]) { //collision
						sick.x = sick.oldX;
						sick.y = sick.oldY;
					} else {
						posMap[posHash] = sick;
					}
				}
				//move healthy
				for (i in model.healthy) {
					healthy = model.healthy[i];
					moveRandom(healthy);
					wrap(healthy);
					posHash = model.getPosHash(healthy);
					if (posMap[posHash]) { //collision
						if (posMap[posHash].type === 'sick') {
							//infected
							console.log('infected! '+model.ratio());
							healthy.type = 'sick';
							model.sick.push(model.healthy.splice(i, 1)[0]);
						}
						healthy.x = healthy.oldX;
						healthy.y = healthy.oldY;
						
					} else {
						posMap[posHash] = healthy;
					}
				}
			}
			function moveRandom(actor) {
				var entropy = Math.random();
				actor.oldX = actor.x;
				actor.oldY = actor.y;
				if (entropy > .5) {
					actor.x++;
				} else {
					actor.x--;
				}
				if (entropy % 0.1 > .05) {
					actor.y++;
				} else {
					actor.y--;
				}
			}
			function wrap(actor) {
				if (actor.x < 0) {
					actor.x = model.width;
				}
				if (actor.x > model.width) {
					actor.x = 0;
				}
				if (actor.y < 0) {
					actor.y = model.height;
				}
				if (actor.y > model.height) {
					actor.y = 0;
				}
			}
			// =fps=
			var drawFps = (function () {
				var fps = 0;
				var frameCount = 0;
				setInterval(function () {
					fps = frameCount;
					frameCount = 0;
				}, 1000); //1 second
				return function () {
					frameCount++;
					ctx.fillStyle = '#000000';
					ctx.fillText(fps+' fps', canvas.width-30, 20);
				}
			})();
			
			// =framerate=
			var drawFramerate = (function () {
				var lastFrame = new Date().getTime();
				return function () {
					var thisFrame = new Date().getTime();
					ctx.fillStyle = '#000000';
					ctx.fillText((thisFrame - lastFrame) / 1000, canvas.width-30, 10);
					lastFrame = thisFrame;
				}
			})();
			
			// ==draw==
			function draw(actors) {
				var actor, i;
				for (i in actors) {
					actor = actors[i];
					switch(actor.type) {
						case 'sick':
							ctx.fillStyle = '#33cc33';
						break;
						case 'healthy':
							ctx.fillStyle = '#777777';
						break;
					}
					ctx.fillRect(actor.x * PIXES_PER_CELL, actor.y * PIXES_PER_CELL, PIXES_PER_CELL, PIXES_PER_CELL);
				}
				//draw infected to health ratio
				ctx.fillStyle = '#000000';
				ctx.fillText(model.ratio(), 1, 9);
			}
			function drawHashPos() {
				for (var w=0; w<model.width; w++) {
					for (var h=0; h<model.height; h++) {
						ctx.fillText(model.getPosHash({x:w, y:h}), w*PIXES_PER_CELL, h*PIXES_PER_CELL+8);
					}
				}
			}
			function drawBG(context) {
				context.fillStyle = '#bbbbbb';
				for (var i in model.obstacles) {
					var o = model.obstacles[i];
					context.fillRect(o.x * PIXES_PER_CELL, o.y * PIXES_PER_CELL, o.w * PIXES_PER_CELL, o.h * PIXES_PER_CELL);
				}
			}
			function randomPos() {
				return {
					x: Math.floor(Math.random() * model.width),
					y: Math.floor(Math.random() * model.height)
				};
			}
			//	=start=
			;(function () {
				if (ANIMATION_FRAME === true && window.requestAnimationFrame) {
					tick();
				} else {
					ANIMATION_FRAME = false;
					setInterval(tick, SPEED);
				}
			})();
		</script>
	</body>
</html>
